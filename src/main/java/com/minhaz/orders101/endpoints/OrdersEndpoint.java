package com.minhaz.orders101.endpoints;


import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.JsonMappingException;
import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.SerializationFeature;
import com.fasterxml.jackson.databind.node.ArrayNode;
import com.fasterxml.jackson.databind.node.ObjectNode;
import com.fasterxml.jackson.datatype.jsr310.JavaTimeModule;
import com.minhaz.orders101.enums.OrderStatus;
import com.minhaz.orders101.interfaces.AddressDao;
import com.minhaz.orders101.interfaces.BasketDao;
import com.minhaz.orders101.interfaces.CustomerDao;
import com.minhaz.orders101.interfaces.LineItemDao;
import com.minhaz.orders101.interfaces.OrderDao;
import com.minhaz.orders101.models.Basket;
import com.minhaz.orders101.models.LineItem;
import com.minhaz.orders101.models.Order;
import jakarta.validation.Valid;
import jakarta.ws.rs.Consumes;
import jakarta.ws.rs.DELETE;
import jakarta.ws.rs.GET;
import jakarta.ws.rs.PATCH;
import jakarta.ws.rs.POST;
import jakarta.ws.rs.Path;
import jakarta.ws.rs.PathParam;
import jakarta.ws.rs.Produces;
import jakarta.ws.rs.ServerErrorException;
import jakarta.ws.rs.core.Response;

import java.lang.reflect.Field;
import java.util.*;

import lombok.extern.slf4j.Slf4j;
import org.javers.core.Changes;
import org.javers.core.Javers;
import org.javers.core.JaversBuilder;
import org.javers.core.diff.Diff;
import org.javers.core.diff.changetype.ValueChange;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;

@Component
@Path("/orders")
@Consumes("application/json")
@Slf4j
public class OrdersEndpoint {

  @Autowired
  private OrderDao dao;

  @Autowired
  private AddressDao addressDao;

  @Autowired
  private CustomerDao customerDao;

  @Autowired
  private LineItemDao lineItemDao;

  @Autowired
  private BasketDao basketDao;

  private final ObjectMapper objectMapper = new ObjectMapper();


  private void replaceNode(JsonNode node, String fieldName, JsonNode jsonValue) {
    if (node.isObject()) {
      ObjectNode objectNode = (ObjectNode) node;
      Iterator<Map.Entry<String, JsonNode>> fields = objectNode.fields();
      while (fields.hasNext()) {
        Map.Entry<String, JsonNode> entry = fields.next();
        String key = entry.getKey();
        JsonNode value = entry.getValue();

        if (key.equals(fieldName)) {
          System.out.println("\nthis is the key " + key);
          System.out.printf("this it the field" + fieldName);
          objectNode.replace(fieldName, jsonValue);
        } else {
          replaceNode(value, fieldName, jsonValue);
        }
      }
    } else if (node.isArray()) {
      ArrayNode arrayNode = (ArrayNode) node;
      for (int i = 0; i < arrayNode.size(); i++) {
        replaceNode(arrayNode.get(i), fieldName, jsonValue);
      }
    }
  }

  @POST
  @Consumes({"application/json"})
  public Response saveOrder(@Valid Order order) throws ServerErrorException {
    log.info("Post method called with order details{}", order);
    // TODO Remove the validation on the ID
    // TODO Make the ID column auto generated by the database

    addressDao.save(order.getDeliveryAddress());
    customerDao.save(order.getCustomer());
    lineItemDao.saveAll(order.getBasket().getLineItems());
    basketDao.save(order.getBasket());

    dao.save(order);
    return Response.ok().build();
  }

  @GET
  @Produces({"application/json"})
  public Response getOrders() {
    List<Order> orders = dao.findAll();
    if (orders.isEmpty()) {
      return Response.status(Response.Status.NOT_FOUND).build();
    } else {
      return Response.ok().entity(orders).build();
    }
  }

  @PATCH
  @Consumes({"application/json"})
  public Response updateDate(Order myOrder) throws Exception {
    // TODO Do something with the order
    Optional<Order> foundOrder = dao.findById(myOrder.getOrderId());
    if (foundOrder.isPresent()) {
      Order oldOrder = foundOrder.get();
      log.info("Found the order with total price {}", oldOrder.getTotalPrice());
      // TODO Compare the input with the stored order. Find out what's changed and update it (look for java library to
      // compare two objects
      Order newOrder = myOrder;
      Basket newBasket = myOrder.getBasket();
      List<LineItem> newLineItem = newBasket.getLineItems();



      System.out.println(newOrder);
      Javers javers = JaversBuilder.javers().build();
      Diff diff = javers.compare(oldOrder, newOrder);
      diff.getChanges().forEach(change -> System.out.println("- " + change));

      // Field[] orderFields = myOrder.getClass().getDeclaredFields();
      // Field[] basketFields = newBasket.getClass().getDeclaredFields();
      // Field[] lineItemFields = newLineItem.getClass().getDeclaredFields();
      //
      // for (Field field: orderFields) {
      // for (int i = 0; i< diff.getChanges().size(); i ++) {
      // ValueChange changes = (ValueChange) diff.getChanges().get(i);
      // if(field.getName().equals(changes.getPropertyName())) {
      // field.setAccessible(true);
      // field.set(myOrder,changes.getRight());
      // dao.save(myOrder);
      // }
      // }
      // }

      objectMapper.disable(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS);
      objectMapper.registerModule(new JavaTimeModule());
      JsonNode rootNode = objectMapper.readTree(objectMapper.writeValueAsBytes(oldOrder));



      diff.getChangesByType(ValueChange.class).forEach(valueChange -> {
        String fieldName = valueChange.getPropertyName();
        Object value = valueChange.getRight();
        Object affectedLocalId = valueChange.getAffectedLocalId();
        JsonNode jsonValue = objectMapper.valueToTree(value);
        replaceNode(rootNode, fieldName, jsonValue);

        rootNode.fieldNames().forEachRemaining(key -> {
          if (key.equals(fieldName)) {
            System.out.println(key);
            ((ObjectNode) rootNode).replace(fieldName, jsonValue);
          }
        });
      });
      Order orderWithUpdatesApplied = objectMapper.treeToValue(rootNode, Order.class);
      dao.save(orderWithUpdatesApplied);

      return Response.ok().build();
    } else {
      return Response.status(Response.Status.NOT_FOUND).build();
    }

  }

  @DELETE
  public Response deleteOrder(Order myOrder) {
    log.info("Delete method called on order {}", myOrder);
    dao.deleteById("1");
    return Response.ok().build();
  }

  @GET
  @Path("/{orderId}")
  @Produces({"application/json"})
  public Response getOrder(@PathParam("orderId") String orderId) {
    Optional<Order> order;
    order = dao.findById(orderId);
    if (order.isPresent()) {
      log.info("Get method called to retrieve order with ID = {}. Order details {}", order.get().getOrderId(), order);
      return Response.ok().entity(order).build();
    } else {
      return Response.status(Response.Status.NOT_FOUND).build();
    }
  }
}
