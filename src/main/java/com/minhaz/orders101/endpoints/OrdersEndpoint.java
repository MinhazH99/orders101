package com.minhaz.orders101.endpoints;


import com.fasterxml.jackson.core.json.JsonWriteFeature;
import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.SerializationFeature;
import com.fasterxml.jackson.datatype.jsr310.JavaTimeModule;
import com.minhaz.orders101.interfaces.AddressDao;
import com.minhaz.orders101.interfaces.BasketDao;
import com.minhaz.orders101.interfaces.CustomerDao;
import com.minhaz.orders101.interfaces.LineItemDao;
import com.minhaz.orders101.interfaces.OrderDao;
import com.minhaz.orders101.models.Order;
import jakarta.validation.Valid;
import jakarta.ws.rs.Consumes;
import jakarta.ws.rs.DELETE;
import jakarta.ws.rs.GET;
import jakarta.ws.rs.PATCH;
import jakarta.ws.rs.POST;
import jakarta.ws.rs.Path;
import jakarta.ws.rs.PathParam;
import jakarta.ws.rs.Produces;
import jakarta.ws.rs.ServerErrorException;
import jakarta.ws.rs.core.Response;
import jakarta.ws.rs.core.Response.Status;
import java.io.IOException;
import java.util.Iterator;
import java.util.List;
import java.util.Map.Entry;
import java.util.Optional;
import lombok.extern.slf4j.Slf4j;
import org.javers.core.Javers;
import org.javers.core.JaversBuilder;
import org.javers.core.diff.Diff;
import org.javers.core.diff.changetype.ValueChange;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;

@Component
@Path("/orders")
@Consumes("application/json")
@Slf4j
public class OrdersEndpoint {

  @Autowired
  private OrderDao dao;

  @Autowired
  private AddressDao addressDao;

  @Autowired
  private CustomerDao customerDao;

  @Autowired
  private LineItemDao lineItemDao;

  @Autowired
  private BasketDao basketDao;
  private final Javers javers = JaversBuilder.javers().build();
  private final ObjectMapper objectMapper = new ObjectMapper();

  @POST
  @Consumes({"application/json"})
  public Response saveOrder(@Valid Order order) throws ServerErrorException {
    log.info("Post method called with order details{}", order);
    // TODO Remove the validation on the ID
    // TODO Make the ID column auto generated by the database

    addressDao.save(order.getCustomer().getInvoiceAddress());
    addressDao.save(order.getDeliveryAddress());
    customerDao.save(order.getCustomer());
    lineItemDao.saveAll(order.getBasket().getLineItems());
    basketDao.save(order.getBasket());

    dao.save(order);
    return Response.ok().build();
  }

  @GET
  @Produces({"application/json"})
  public Response getOrders() {
    List<Order> orders = dao.findAll();
    if (orders.isEmpty()) {
      return Response.status(Response.Status.NOT_FOUND).build();
    } else {
      return Response.ok().entity(orders).build();
    }
  }


  @PATCH
  @Consumes({"application/json"})
  public Response updateDate(@Valid Order orderToUpdate) throws IOException {
    Optional<Order> orderInStorage = dao.findById(orderToUpdate.getId());
    if (orderInStorage.isPresent()) {
      Order oldOrder = orderInStorage.get();
      Diff diff = javers.compare(oldOrder, orderToUpdate);
      System.out.println(diff.prettyPrint());

      objectMapper.disable(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS);
      objectMapper.disable(JsonWriteFeature.QUOTE_FIELD_NAMES.mappedFeature());
      objectMapper.registerModule(new JavaTimeModule());
      JsonNode rootNode = objectMapper.valueToTree(oldOrder);

      findAndUpdate(diff.getChangesByType(ValueChange.class), rootNode);

      Order orderWithUpdatesApplied = objectMapper.treeToValue(rootNode, Order.class);
      System.out.println(orderWithUpdatesApplied);
      addressDao.save(orderWithUpdatesApplied.getDeliveryAddress());
      customerDao.save(orderWithUpdatesApplied.getCustomer());
      lineItemDao.saveAll(orderWithUpdatesApplied.getBasket().getLineItems());
      basketDao.save(orderWithUpdatesApplied.getBasket());
      dao.save(orderWithUpdatesApplied);

      return Response.ok().build();
    } else {
      return Response.status(Response.Status.NOT_FOUND).build();
    }
  }

  /**
   * this method assumes that field names in the json are unique at their level. For example, there may be several
   * objects with a property called 'unitPrice' but those will be siblings.
   *
   * @param changesByType the list of changes from javers
   * @param node the current json node
   */
  private void findAndUpdate(List<ValueChange> changesByType, JsonNode node) {
    // loop through the changes
    changesByType.forEach(change -> {
      var changedProperty = change.getPropertyName();
      var changedId = change.getAffectedLocalId();
      var parents = node.findParents(changedProperty);
      parents.forEach(parent -> {
        if (parent.get("id").textValue().equals(changedId) && parent.get(changedProperty) != null) {
          amendNode(parent, change);
        }
      });
    });
  }

  private void amendNode(JsonNode parent, ValueChange change) {
    Iterator<Entry<String, JsonNode>> iter = parent.fields();
    while (iter.hasNext()) {
      Entry<String, JsonNode> jsonField = iter.next();
      if (change.getPropertyName().equals(jsonField.getKey())) {
        jsonField.setValue(objectMapper.valueToTree(change.getRight()));
        break;
      }
    }
  }

  @DELETE
  public Response deleteOrder(Order myOrder) {
    log.info("Delete method called on order {}", myOrder);
    dao.deleteById(myOrder.getId());
    return Response.ok().build();
  }

  @GET
  @Path("/{orderId}")
  @Produces({"application/json"})
  public Response getOrder(@PathParam("orderId") String orderId) {
    Optional<Order> order;
    order = dao.findById(orderId);
    if (order.isPresent()) {
      log.info("Get method called to retrieve order with ID = {}. Order details {}", order.get().getId(), order);
      return Response.ok().entity(order).build();
    } else {
      return Response.status(Status.NOT_FOUND).build();
    }
  }
}
